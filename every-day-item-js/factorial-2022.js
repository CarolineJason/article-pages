// https://blog.csdn.net/qq_33556393/article/details/78896881
// Done~~~
// 计算2022的阶乘
// n! = n * (n - 1) * (n - 2)... * 1
// 4! = 4 * 3 * 2 * 1 = 24
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

/**
 * 主要思想: 利用数组存储每一位计算后的结果，每轮运算只确定一位的值
 * 4! = 24 => [4, 2]
 * 5! = 120 => [0, 2, 1]
 * 1! => [1] 2! => [2] 3! = [6]
 * 涉及到两重循环运算
 *  1. 外层循环确定一个阶乘值
 *   for (let i = 1; i < n; i++) {}
 *   每一轮循环确定一个阶乘值，
 *   i = 1，确定1的阶乘，i = 4，确定4的阶乘值，最终都是由数组a表示
 *  2. 内层循环是计算当前阶乘数的
 *   j作为索引，c表示进位，
 *   如果数组a位数没有计算完成，或者进位没有处理完成，则继续处理
 *   for (let j = 0, c = 0; j < a.length || c != 0; j++)
 *   用m保存相乘的结果（阶乘数 * 当前位数 + 上一位的进位数）
 *   当前位数 = m % 10 
 *   进位 = (m - 当前位数) / 10
 */
function factorial2(n) {
  let a = [1];
  for (let i = 1; i <= n; i++) {
    for (let j = 0, c = 0; j < a.length || c != 0; j++) {
      let m = j < a.length ? i * a[j] + c : c;
      a[j] = m % 10;
      c = (m - a[j]) / 10;
    }
  }
  return a.reverse().join('');
}

//     24
// *    5
//   -----
//    120
// [4, 2] * 5
// 4 * 5 = 20     20 % 10 = 0 当前位取0，进位2 = (20 - 0) / 10
// 2 * 5 + 2 = 12 12 % 10 = 2 当前位取2，进位1 = (12 - 2) / 10
//                            当前位去1 => [0, 2, 1]

// 10! = [0, 0, 8, 8, 2, 6, 3]
// i = 11
// 1: m = 11 * 0 = 0       a[0] = 0 c = 0
// 2: m = 11 * 0 = 0       a[1] = 0 c = 0
// 3: m = 11 * 8 = 88      a[2] = 8 c = 8
// 4: m = 11 * 8 + 8 = 96  a[3] = 6 c = 9
// 5: m = 11 * 2 + 9 = 31  a[4] = 1 c = 3
// 6: m = 11 * 6 + 3 = 69  a[5] = 9 c = 6
// 7: m = 11 * 3 + 6 = 39  a[6] = 9 c = 3
// 8:                      a[7] = 3